Dear ImGui (Docking Branch) – Internal Architecture Deep Dive

Example of Dear ImGui’s docking system in action, with multiple docked windows (some tabbed) and an ImPlot chart.

Immediate Mode GUI Core Concepts

Dear ImGui is an immediate mode GUI library. This means the UI is fully regenerated each frame by calling ImGui functions, rather than maintaining persistent widget objects. ImGui calls (like ImGui::Button, ImGui::SliderFloat, etc.) emit vertices and draw commands on the fly into internal buffers. After building the frame’s UI, ImGui outputs optimized draw data (vertex buffers + a small list of draw calls) . This approach minimizes retained state and avoids complex scene graphs. Instead of storing a widget hierarchy, ImGui simply processes UI logic every frame and uses unique IDs to associate interactive state with widgets.

Frame lifecycle: Each frame, the typical sequence is: ImGui::NewFrame() → user submits UI widgets (calling ImGui APIs) → ImGui::Render() (or automatically at end of frame) which finalizes geometry. The result is a list of draw lists with vertices and texture coordinates, which the application then renders via a GPU API. ImGui does not directly execute GPU calls as you issue widgets; it batches all UI into draw lists and defers rendering to the end of the frame . This avoids the “immediate mode rendering = slow” pitfall by keeping actual GPU draw calls minimal (often just a few draw calls for the entire UI) .

Minimal state retention: ImGui’s design keeps synchronization and stored state to a minimum  . The library doesn’t require user-maintained UI state; for example, you don’t create a Button object and track it – you simply call ImGui::Button(label) every frame and ImGui internally handles whether it’s pressed, hovered, etc. Any needed persistent state (like a checkbox’s checked state, input text content, or window collapse state) is stored internally by ImGui using IDs. ImGui generates IDs for widgets based on labels or explicit PushID/PopID scopes. These IDs index into internal state tables so that, for example, if a text input is active, ImGui knows to preserve its buffer or cursor position across frames. This allows ImGui to be largely stateless from the user’s perspective – the state lives in ImGui’s context and is looked up by ID each frame. This design greatly reduces user-side bookkeeping and errors .

ImGui context and IO: All ImGui state is contained in an ImGuiContext (with a default context usually created for you). This includes information about active widget IDs, hovered elements, the current UI window stack, etc. One important piece is the ImGuiIO structure (accessible via ImGui::GetIO()), which holds configuration flags, input state, and settings. ImGuiIO is how you configure ImGui (e.g. enabling flags for docking or keyboard navigation) and feed it input events. The context also includes an ImGuiStyle (colors, sizes, layout defaults) and an ImFontAtlas (glyph atlas) that stores fonts and icons for rendering text.

ID stack and state management: ImGui uses an ID stack to allow the same widget function to be used multiple times with distinct state. For example, calling ImGui::Button("OK") twice will refer to the same label; to differentiate them, you can push an ID (or use ImGui::PushID) or provide a unique label (e.g. “OK##1” and “OK##2”). This ID mechanism ensures that interactions map to the correct widget. Internally, ImGui maintains things like ImGuiContext::ActiveId (the ID of the currently active widget, e.g. the one being clicked or edited) and HoverId (ID under the mouse). Only one widget can be active at a time (e.g. the one being dragged or with keyboard focus). ImGui’s internal state for each widget is typically very lightweight – often just a boolean or numeric value, or stored in a window’s storage. More complex state (text input buffers, tree node open/close state, etc.) are managed in structures tied to the widget’s ID.

One-frame memory: By default, if something is not updated in a frame, it effectively ceases to exist in the UI. This means if you stop calling a widget, its state might be gone (unless stored elsewhere). This approach simplifies memory management and avoids long-lived UI objects. However, ImGui does provide mechanisms to preserve some state across frames or sessions: for example, window positions/sizes and docking layouts are saved to an .ini file automatically. Widgets like collapsing headers or selectable items have flags or API calls to check/change their persistent state (which ImGui tracks internally). In general though, ImGui emphasizes computing the UI on demand, which is why it is so easy to create dynamic interfaces that reflect live data .

Input Handling and IO System

ImGui doesn’t directly handle the operating system’s input events; instead it expects the host application to feed input data into ImGui each frame. The ImGuiIO structure has fields for mouse position, mouse buttons, keyboard keys, mouse wheel, key modifiers, and more. A typical integration will call something like io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddKeyEvent(), etc., whenever the application receives input events, or update io.MousePos, io.MouseDown[], etc., each frame before calling NewFrame(). ImGui then uses that buffered input info during NewFrame() to update its internal state (e.g. which window is hovered, which widget is active).

Mouse input: ImGui uses the mouse for hovering, clicking widgets, resizing windows, dragging sliders, etc. The backend sets io.MousePos and an array of io.MouseDown[5] for buttons, plus io.MouseWheel for scroll. ImGui also supports high-level drag-and-drop via its API (BeginDragDropSource, SetDragDropPayload, BeginDragDropTarget, etc.). Internally, when you call BeginDragDropSource(), ImGui locks an internal payload (an ImGuiPayload struct) with the data/type you provide and notes that a drag is in progress. If you call BeginDragDropTarget() on another widget and the mouse is hovering it while a drag payload is available, ImGui will consider that target and allow you to accept the drop. The drag and drop system uses ImGui’s frame-by-frame polling (no OS drag-drop) – e.g. it shows a tooltip by default while dragging (unless you use ImGuiDragDropFlags_SourceNoPreviewTooltip). This system relies on ImGui’s global state to hold the current drag payload and target. It’s a good example of ImGui’s immediate mode: the UI for the drag is drawn in real-time (as a floating tooltip), and the acceptance is checked each frame on potential targets.

Keyboard input and focus: Keyboard is used both for typing into text fields and for triggering shortcuts or navigation. ImGui has a concept of an active focus for text input – only one text input widget (or combo, etc.) can capture keyboard input at a time. The backend should send character input via io.AddInputCharacter() (for text entry) and update io.KeysDown[512] for key presses. ImGuiIO also holds key mod flags (Shift, Ctrl, Alt, Super) which the backend sets. ImGui provides some built-in keyboard controls: e.g. when a text field is active, it processes arrow keys, Home/End, Delete, etc., internally. It also has global shortcuts: for example, by default pressing Ctrl+Tab opens a window list to switch to another window. The docking branch adds shortcuts like holding Shift while dragging a window to disable docking . These behaviors are handled in ImGui’s internal code when certain keys are detected.

Navigation (keyboard/gamepad): ImGui supports a “navigation” mode for keyboard/gamepad so that UIs can be used without a mouse (useful for gamepad input on consoles, or accessibility). This is off by default; to enable it, you set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard for keyboard or NavEnableGamepad for game controllers . When enabled, ImGui will react to arrow keys or gamepad DPAD by moving a highlight (the “nav focus”) through widgets. The highlight can be activated (e.g. pressing Enter or gamepad A) to press buttons, etc. Internally, ImGui’s nav system uses a notion of a “focus scope” and it keeps a NavId (the ID of the currently focused item) and moves it based on directional input. The backends need to feed the appropriate keys (ImGui has key enums for gamepad buttons, which the backend maps). This system is fairly complex internally (to allow grid navigation, wrapping, etc.), but from an integration standpoint it’s mostly about enabling the flags and ensuring the backend passes arrow keys, tab, etc. ImGui’s nav system is increasingly robust and allows full control of the UI without a mouse .

Input capture and forwarding: Since your application is also receiving input, there’s a question of when to let ImGui consume inputs vs when the app should handle them. ImGui’s ImGuiIO has flags like io.WantCaptureMouse and io.WantCaptureKeyboard. After NewFrame(), ImGui sets these to tell you if the UI wants the mouse/keyboard. For example, if the user is clicking on an ImGui window or dragging a slider, WantCaptureMouse will be true, so your game/app should not also treat that click as e.g. a camera movement. Similarly, WantTextInput indicates ImGui has an active text input and is expecting character inputs (you might want to show an OS onscreen keyboard on mobile, for instance). The integration loop typically checks these flags around event handling. This mechanism allows “global” keyboard shortcuts in your app: e.g., if WantCaptureKeyboard is false (meaning ImGui has no active text or popup that wants exclusive keyboard focus), you could treat a key press as a global hotkey in your application. ImGui doesn’t have a built-in global shortcut manager; you implement that in your app code, using these flags to decide priority.

Clipboard and IME: The ImGuiIO interface also defines callbacks for things like clipboard copy/paste and IME (Input Method Editor) support for Asian languages. The backend or app can provide SetClipboardTextFn and GetClipboardTextFn so ImGui can interact with the OS clipboard when the user presses Ctrl+C/V in an active text field. For IME, ImGui provides a way to let the OS handle complex input for languages – typically the backend sets io.ImeWindowHandle (a native window handle) and ImGui will call platform APIs to position the IME candidate window near the text input. Proper IME support requires platform-specific code in the backend.

In summary, ImGui’s input system is a thin layer that relies on the host environment to feed events. Once the data is in ImGuiIO, ImGui takes over and updates its internal state for widgets, focus, hover, etc., each frame. Because ImGui runs in the application’s main loop, it has immediate responsiveness to input: e.g. as you hold and drag a slider, the value changes instantly because the UI is recalculated every frame. And because ImGui aims to minimize surprise, it gives the application information (via flags) about what it’s using, so you can coordinate ImGui with the rest of your program’s input handling.

Rendering Pipeline and Draw Lists

After UI is built each frame, ImGui produces a set of drawing commands that the application must render. ImGui’s output is encapsulated in draw lists and the draw data:
	•	ImDrawList: As ImGui submits widgets, it funnels all the low-level drawing into ImDrawList objects. An ImDrawList is essentially a list of vertices, indices, and draw commands. Each ImGui window has its own ImDrawList (accessible via ImGui::GetWindowDrawList() during widget creation) which accumulates all the draw primitives for that window. ImGui also maintains some internal draw lists for things like modal overlays or debug draw. When you call a function like ImGui::Text("Hello"), ImGui will append vertices for the text (via font atlas) into the current window’s draw list, and possibly merge them with the previous draw call if possible (e.g. same texture and state). Draw lists are layered: a typical ImGui window uses channels to separate background, contents, and foreground (for example, so that the window’s border and title bar are drawn after its contents). The draw list API (ImDrawList* draw_list = ImGui::GetWindowDrawList()) is also exposed so you can draw custom shapes (lines, rectangles, images, bezier curves, etc.) into it.
	•	ImDrawCmd: Within a draw list, ImGui groups vertices into draw commands whenever a change in render state occurs. A draw command basically consists of: a texture id (which identifies the font atlas or user-attached texture to use), a clipping rectangle (to confine drawing to a window’s visible region), and a count of indices to draw. If you have a window with only text using the same font, you might end up with one draw command covering all text. If you mix an image (with a different texture) in the middle, the draw list will split into two commands – one for all vertices up to the image (using font texture), then one for the image’s quad (using that image’s texture), then maybe another for subsequent text. ImGui tries to batch as much as possible to minimize state changes. All triangles that share the same texture and scissor are rendered in one go. The draw list keeps an IdxBuffer (index buffer) and VtxBuffer (vertex buffer) which grow as needed.
	•	ImDrawData: At the end of the frame, after calling ImGui::Render(), you retrieve an ImDrawData object via ImGui::GetDrawData(). This structure contains the aggregated draw lists for the frame. In single-viewport mode (just one window or one OS window), it will have all the draw lists concatenated in the correct order for rendering, and possibly some information like the total display size. In multi-viewport mode (docking branch feature), the draw data can be separated per viewport (each viewport gets its own ImDrawData). The draw data basically tells your renderer: “here are N draw lists; each draw list has a series of draw commands with associated vertex/index data; please draw them in order.”

Coordinate system: ImGui uses a coordinate system where (0,0) is the top-left of the application window (or of each viewport). Positions are typically in pixels. Each window has a position (ImGuiWindow->Pos) in absolute coordinates, and the draw list coordinates for window contents are generally window-local (0,0 at window top-left) but then offset by the window’s absolute position when finalizing. When multiple viewports are enabled, coordinates become absolute across the desktop , which means ImGui is effectively using global screen coordinates for everything (the main viewport’s top-left might be (0,0) and another monitor’s windows will have coordinates offset by that monitor’s origin). This is handled internally by ImGui and the backend (which sets up transformation for each viewport’s render).

Rendering the draw data: The application (or the provided backend renderer) is responsible for taking ImDrawData and issuing actual rendering API calls. ImGui is render API-agnostic – it doesn’t know if you’re using OpenGL, Vulkan, DirectX, etc. Official backends exist for many graphics APIs that know how to take ImDrawData and render it. For example, the OpenGL backend will typically: bind the UI shader (a simple textured alpha-blend shader), set up an orthographic projection to map coordinates to screen, upload the vertex/index buffers (or use a persistent buffer and just sub-update), then iterate through ImDrawData’s command lists. For each ImDrawCmd, it will set the scissor/clipping rectangle (using cmd.ClipRect) and bind the right texture (the cmd.GetTexID() which for ImGui default content is the font atlas, or any user-attached texture for images) , then call the draw function (e.g. glDrawElements with the index count). Many ImGui backends also handle the case of the vertex indices being 16-bit by default – if the buffer exceeds 65k vertices, ImGui can use 32-bit indices or the backend can use a technique with base vertex (as indicated by the ImGuiBackendFlags_RendererHasVtxOffset flag). This is important when using custom widgets or big content (e.g. ImPlot can generate a lot of vertices), and ImGui’s documentation explicitly notes enabling 32-bit indices for such cases .

Draw list internals: ImDrawList provides a variety of low-level primitives. For example, ImDrawList::AddLine() will push two vertices and an index pair; AddRect() will push 8 vertices and indices (or more if thick line with round corners approximated as many segments). Text is rendered by ImGui using textured triangles from the font atlas: each character is a quad (two triangles) referencing the atlas texture. ImGui can pack a lot of UI elements into one atlas (for example, icons or custom images can be added to the font atlas to reduce texture switches). The ImDrawListSharedData holds settings like the curve tessellation tolerance and line AA settings which all draw lists use. ImGui by default uses antialiased lines and shapes, achieved by drawing an extra outline with alpha to smooth edges (or using the texture-based AA for lines if enabled in style). One should ensure the backend’s blending state and texture filtering is set so these look correct (e.g. enabling bilinear filtering on the font texture for nice AA) .

ImGui uses some clever techniques for layering UI. For example, windows can be drawn in a different order than they appear in code to satisfy z-order (last active window appears on top). Internally ImGui will sort windows by an order (based on focus) and then render their draw lists accordingly. For complex cases like a window with a modal on top, it can use additional draw lists for the modal that come after others. Additionally, ImGui allows “channels”: using ImDrawListSplitter, it can split a draw list into multiple layers then merge them. This is used for things like separating scrollable region content from non-scrollable headers within the same window’s draw list. All of this is done to minimize GPU state changes while correctly layering the primitives.

Performance: The immediate-mode approach means ImGui will regenerate all vertex data every frame, but the outcome is highly optimized for rendering. The number of actual GPU draw calls is kept low , and ImGui’s output data is layouted sequentially in memory, making it cache-friendly. An example of ImGui’s efficiency: the entire UI in an average tool might be drawn with perhaps a few hundred thousand vertices, which modern GPUs handle easily, and those might be submitted in maybe a few dozen draw calls or less. The CPU cost of building the UI is usually modest – string rendering is one of the larger costs (ImGui does format text and occasionally does UTF-8 decoding for text), but even that is minor unless you print thousands of lines each frame. ImGui avoids heavy usage of STL and heap allocation in its main loop; most ImVector buffers (ImGui’s internal vector type) are allocated with some slack and reused each frame, so allocations only happen when you expand beyond previous high watermarks. This means after some frames, things stabilize and no new allocations occur during rendering, reducing CPU spikes. The result is that Dear ImGui can be used in performance-sensitive applications (like games or real-time tools) with negligible impact on frame rate .

Backend Abstraction: Platform and Renderer Bindings

Dear ImGui is platform-agnostic and renderer-agnostic. To function, it needs two glue layers: one to handle operating system/platform integration (windowing, timers, clipboard, input) and one to handle rendering API calls. The library provides example backends (in the backends/ folder) for many common combinations: e.g. imgui_impl_glfw.cpp + imgui_impl_opengl3.cpp, or SDL2 + DirectX11, Win32 + DirectX12, etc. You can mix and match a platform backend and a renderer backend appropriate for your environment .

Platform backend (OS integration): The platform backend’s role is to initialize ImGui and feed it inputs each frame. Using GLFW as an example, the imgui_impl_glfw.cpp sets up key callback, mouse callback, etc., and in its NewFrame() function it will populate ImGuiIO with the latest input states from GLFW. It also handles things like cursor shape (ImGui can request OS cursor changes, e.g. ImGui::SetMouseCursor sets io.MouseCursor, and the backend will change the actual OS cursor icon). The platform backend may also handle the creation of the main application window or use an existing one. For multiple viewports (see next sections), the platform backend is responsible for creating additional OS windows when ImGui requests them. The platform backend also often ties into the OS clipboard API (for copy/paste support) by assigning io.SetClipboardTextFn and GetClipboardTextFn. In some cases, it handles IME (for text input for languages) by monitoring when io.WantTextInput is true and enabling the OS IME.

Renderer backend (graphics API): The renderer backend’s job is to take ImGui’s ImDrawData and draw it with the chosen graphics API. For example, the OpenGL3 backend compiles a simple GLSL shader that samples the font texture and does vertex transform. It sets up a VAO with position/UV/color attributes matching ImGui’s vertex format, and it creates/binds the font atlas as an OpenGL texture. Each frame, the backend will update or map a vertex buffer with ImGui’s vertices, then loop through ImDrawData’s command lists and issue glDrawElements calls. It respects the Cmd->ElemCount (number of indices), uses Cmd->ClipRect to set glScissor (to clip to the widget’s region), and binds the texture given by Cmd->GetTexID(). ImGui’s default ImTextureID is void* to allow it to be either an OpenGL GLuint or a DirectX ID3D11ShaderResourceView* or any other identifier – the backend knows how to interpret it for its API. The renderer backend also sets up things like blending (typically standard alpha blending), enables scissor test for clipping, and disables depth testing (ImGui draws UI in a 2D overlay usually).

Separation of concerns: This split means Dear ImGui core doesn’t need to know about OS or GPU details. You can integrate ImGui into any engine by writing or using an appropriate backend. If your engine already has windowing and rendering, you can adapt ImGui by writing a few functions to feed input and render the draw lists. Many engines and frameworks have ImGui integration available (either via these backends or custom ones)  . The official backends are provided as a reference and convenience; they’re not strictly part of the core library but they are widely used. In most cases you can use them unmodified. For example, if you have a GLFW+OpenGL application, simply include and call ImGui_ImplGlfw_InitForOpenGL(window, true) and ImGui_ImplOpenGL3_Init(nullptr) (with your GL version), then each frame ImGui_ImplGlfw_NewFrame(); ImGui_ImplOpenGL3_NewFrame(); ImGui::NewFrame(); ... ImGui::Render(); ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());. This sequence wires up everything. The backend examples in the ImGui repository’s examples/ folder demonstrate this clearly.

Multi-Viewport support in backends: The docking branch introduces multi-viewport, which requires more work in the platform backend. ImGui adds a structure ImGuiPlatformIO that contains function pointers the backend should fill for creating, destroying, showing/hiding secondary windows (platform viewports)  . The backend basically implements: “create a new OS window when ImGui needs one, with the requested size/title”; “destroy it when ImGui is done”; “update ImGui with the position/size of platform windows”; and “swap buffers and handle input for those windows.” The official backends like GLFW, SDL, Win32 in the docking branch have this code. When multi-viewport is enabled, ImGui will call ImGuiPlatformIO::Platform_CreateWindow etc. to manage extra windows. We’ll discuss this more in the Multi-Viewport section, but it’s worth noting that the backend abstraction cleanly extends to handle multiple windows.

Backend capabilities flags: ImGuiIO and ImGuiBackendFlags allow backends to advertise capabilities. For example, io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors if the backend supports changing the OS cursor icon, or HasSetMousePos if it can reposition the mouse. For renderer, ImGuiBackendFlags_RendererHasVtxOffset indicates the renderer can handle large meshes with offset indices (so ImGui can use 32-bit indices or multiple draw calls to extend the 16-bit limit) . These flags let ImGui enable/disable certain features accordingly.

In summary, the platform backend feeds events and handles OS specifics, the renderer backend draws the triangles. ImGui decouples these concerns so you can mix and match as needed. It’s designed to be easy to integrate – in many cases, it’s just a matter of copying the backend files and calling the init/newframe/render functions in the right places . The backend code is also fairly straightforward, so customizing it (e.g. to work with a custom engine’s windowing) is often not too difficult, essentially “fill in the blanks” based on existing examples .

Creating Custom Widgets and Extensions

One of Dear ImGui’s strengths is that it’s easy to extend with custom widgets. Because it’s immediate mode and open source, you have full control to create new UI elements by building on ImGui’s fundamentals. There are two primary approaches to making a custom widget or control:
	1.	Use ImGui’s public API (composition) – This is the simpler, forward-compatible method. You can construct a custom widget by calling existing ImGui items and drawing functions. A common technique is to use ImGui::InvisibleButton() to create an invisible interactive region that still handles mouse input (hover, click, drag) . For example, if you wanted to create a custom knob dial, you could: create an InvisibleButton with a certain radius (so it captures clicks/drags), then use ImGui::IsItemActive() or IsItemHovered() to check interaction state, and finally use ImDrawList to draw the knob (a circle and a line indicating angle) manually. InvisibleButton provides you with the ImGui-provided behavior of a button (it updates the active id, and returns true if clicked), but with no visuals – you supply the visuals. You can also use other public utilities: e.g., ImGui::IsItemClicked(), ImGui::GetMouseDragDelta() to get how far the mouse moved while an item is active, etc., to implement drag behaviors. The ImGui demo (ShowDemoWindow) has examples of creating widget types by querying item state. This approach keeps you within the official API – which means it’s robust to future ImGui updates (no need to touch internal code). It covers many needs. For instance, you could implement a color picker by combining existing ImGui color edit logic with some custom drawn palette squares, etc.
	2.	Use ImGui’s internal API (imgui_internal.h) for lower-level control – ImGui exposes some of its internal functions/structures if you include imgui_internal.h. These are not guaranteed API-stable, but give you more fine-grained control akin to what ImGui’s own widgets use. For example, you could use ImGui::ItemAdd() to add a rectangular item to the layout and get an ID, then call ImGui::ButtonBehavior() to handle the hover/active logic (this is what ImGui uses under the hood for buttons) . This yields booleans for pressed/hovered states. You can then render using ImGui::RenderFrame or your own draw calls. Using internals, you can also manipulate ImGui’s state directly (e.g., set the ActiveID). However, this requires understanding ImGui’s internal conventions (for example, calling ItemSize() to advance the layout cursor, etc.)  . The ImGui repository issues and wiki sometimes provide guidance on this (Omar, the author, often hints at using ButtonBehavior() for custom widgets). While powerful, internal usage means you need to be cautious when updating ImGui, as these internal APIs can change.

For most users, method (1) is sufficient and safer . For example, if you want a toggle switch that looks like a checkbox but with a custom icon, you might create it by detecting clicks on an invisible button and toggling a boolean, then drawing a custom shape (circle for “on”, etc.) based on that boolean. ImGui’s ability to query widget status (active, hovered, clicked) is extremely useful here – you don’t have to write all the event handling from scratch; ImGui already figures out if your invisible button was clicked, or is being held, etc., and you just react to it.

Custom drawing: Regardless of approach, the custom widget will likely involve using the ImDrawList to draw shapes. ImGui provides a default drawing context via ImGui::GetWindowDrawList(). You can draw primitives (lines, rectangles, arcs), images (via AddImage), and text (AddText) at specific positions. These draw calls respect the current window’s clipping rectangle by default. You can also push your own clipping rectangle or transform if needed. Because you’re drawing in the immediate mode pass, your drawings automatically appear in the correct order relative to other UI (depending on when you call them).

Layout considerations: When making a custom widget, you must consider how it fits into ImGui’s layout (the cursor positioning for the next item). Usually you will call ImGui::InvisibleButton() or ImGui::Button() which already takes care of layout (advancing the cursor by the item size). If you don’t use an existing item to reserve space, you might need to call ImGui::Dummy() or ImGui::ItemSize() to advance the layout manually, otherwise subsequent items could overlap your custom drawn content  . For instance, after drawing a knob of 50x50 pixels, you’d call ImGui::ItemSize(ImVec2(50,50)) to tell ImGui that an item of that size has been used.

Interactivity and state: ImGui makes it easy to handle common interactions. If your widget is interactive (e.g. draggable or editable), it should have a unique ID (you can push an ID or use ImGui::PushID(ptr) etc. around it). This ensures it doesn’t conflict with other items. If it becomes active (e.g. user is dragging it), ImGui will set it as ActiveId. You typically don’t need to call SetActiveID manually (unless using internal API) – calling a button or using ButtonBehavior will do that for you. To detect changes, you might use ImGui’s return values or IsItemDeactivatedAfterEdit() (commonly for sliders to detect when a drag ends). For example, a color picker might want to know when the user finished picking (mouse released).

In practice, many complex extensions to ImGui have been created this way. For example, ImGuizmo is a 3D gizmo widget for ImGui that allows manipulating 3D transform widgets (like move/rotate handles). It uses ImGui to create an overlay in a 3D viewport and captures mouse drags, then uses ImDrawList to draw the axis arrows and rotation circles. Another example is node editors (for visually editing graphs): libraries like imgui-node-editor create interactive nodes and links by treating each node as a mini ImGui window or using ImGui child regions, and drawing connection lines via ImDrawList. These are all built on ImGui’s public or internal APIs.

Using C++ classes: While ImGui is C-based API, you can wrap custom widgets in your own classes for convenience – just ensure the actual rendering and input logic calls ImGui functions appropriately. Some people encapsulate ImGui calls into higher-level widgets (like a plotting widget, etc.), which is fine as long as it ultimately issues ImGui calls each frame.

Comparison with retained mode: In traditional retained GUIs, making a custom widget might require subclassing a base Widget class, handling various events, and ensuring proper invalidation and repaint. In ImGui, a custom widget is often just a function that uses ImGui’s existing tools. This can be incredibly productive – you can prototype a new UI component in minutes. The downside is you don’t get a lot of default behavior for free (you might need to handle keyboard interactions for your widget if needed, etc.), but you can often compose existing ones (for example, you could just reuse an ImGui SliderFloat but draw a custom background behind it).

To summarize, customizing ImGui is done either via the public API approach, leveraging things like InvisibleButton and draw lists (recommended for most cases) , or via the internal API approach for more control at the cost of using non-public functions. ImGui’s architecture, despite being immediate, is flexible enough that almost any widget or GUI control can be implemented on top of it. This flexibility has led to an ecosystem of extensions (some described at the end) that show how far you can go by combining ImGui’s building blocks.

Docking System Internals (Docking Branch)

One of the major features in the “docking” branch of ImGui is the ability to dock windows to each other – arranging multiple windows in a single container with tabs, or splitting regions dynamically (similar to many IDEs or editor applications). In ImGui’s default (non-docking) behavior, each window is a floating, separate entity. The docking system changes this by introducing the concept of Dock Nodes and Dock Spaces to manage multiple windows in a unified layout.

Enabling Docking: Docking is not enabled by default even when using the docking branch (to maintain backward compatibility). To use it, you must set the config flag: ImGui::GetIO().ConfigFlags |= ImGuiConfigFlags_DockingEnable; . Once enabled, ImGui will automatically allow windows to be docked via drag and drop. Typically, you will also create a persistent dockspace in your main window (or across the entire viewport). For example, the ImGui demo does this by creating a fullscreen window with the ImGuiWindowFlags_DockSpace flag or by calling ImGui::DockSpace() in a window that you designate as the central area. This dockspace act as a host where other windows can dock. It’s common to call DockSpaceOverViewport() to make the entire main viewport a docking area (so windows can be docked anywhere in the main window) . But you can also have specific regions as dockspaces.

Dock nodes: Internally, ImGui represents the docking layout using a tree of ImGuiDockNode structures. A DockNode is either a leaf node (hosting one or more windows as tabs) or a split node (with two child DockNodes, split horizontally or vertically)  . Every docked window is attached to a DockNode. When no docking is used, windows float freely and have no dock node. When the user drags one window into another, ImGui either merges them into a tabbed node or splits an existing node to accommodate them. Each DockNode has an ID, size, position, and pointers to its children and parent  . If multiple windows share a DockNode, ImGui creates a tab bar (ImGuiTabBar) to allow tabbing between them . The tab bar is drawn in the host window’s title area.

There are two kinds of DockNodes in terms of their lifetime and ownership:
	•	Dockspace node: This is a dock node explicitly created by the user in a location. For example, if you call DockSpace() in a window, ImGui will create a dock node covering that window’s content region. This node’s size/pos is tied to that host window (the host window is essentially a container for the dockspace)  . A dockspace node often acts as the root of a docking hierarchy. A special property of a dockspace’s root node is the concept of a Central Node: one node that fills any leftover space and remains visible even if empty . The central node is typically the one that wasn’t split off to the sides – it ensures that a dockspace always has an area for windows (and cannot be fully empty).
	•	Floating dock node: If you drag out a tab to separate it (undock it) and it becomes its own floating window, ImGui actually represents that as a dock node too, but one that is not tied to a user-created dockspace. ImGui will create a temporary host window for it. This floating dock node can itself be split/tabbed if you dock more windows into it. Essentially, any independent group of docked windows (whether in a user-defined dockspace or a floating one) is managed by a DockNode hierarchy.

Docking behaviors: By default, with docking enabled, the user can drag a window by its title bar (or tab) and drop it onto another window. ImGui shows a preview outline indicating the possible docking location (edge or as tab). Docking can happen in two ways:
	•	Splitting: dropping a window on the edge of another splits that target node into two, side by side (or top/bottom). For example, dragging a window to the right edge of another might create a vertical split: the target window now occupies the left part, and the dragged window becomes a tab in a new node on the right. The split ratio can be adjusted by dragging the divider that appears between the nodes.
	•	Tabbing: dropping a window in the center of another window’s title bar (or on its tab bar) will merge them into one node with multiple tabs. The windows then share the same space and are accessible via tabs.

Users can also rearrange tabs by dragging them within a tab bar, or detach a tab by dragging it out. Undocking can be done by dragging a window out of its dock node. If you drag the only tab out, the node might disappear (if it was a floating node, the host window closes). If you drag one tab out of a multi-tab node, that window simply leaves and becomes a new floating node or joins another dockspace if you drop it there. ImGui also supports holding Shift to disable docking while dragging (so you can force a window to float) . Conversely, there’s an io.ConfigDockingWithShift option to require holding Shift to enable docking, depending on user preference .

Dock node structure details: Each ImGuiDockNode stores flags and settings:
	•	Flags can include things like ImGuiDockNodeFlags_NoSplit (to disallow further splitting of that node) or NoTabBar (to hide the tab bar when only one window is present, which by default ImGui can do to save space) .
	•	A DockNode’s list of windows (DockNode->Windows) holds ImGuiWindow pointers for all windows in that dock (when it’s a leaf node)  . The VisibleWindow points to the currently active one (selected tab)  .
	•	The SplitAxis indicates horizontal vs vertical split for non-leaf nodes .
	•	The Size and Pos are updated to match the host region; SizeRef is used to remember a user-resized split size  .
	•	DockNodes form a tree – a root node may have two children if split, and each child could further split, etc. There’s also pointers like DockNode->ParentNode and a back-pointer from ImGuiWindow to its DockNode (when docked).
	•	Each DockNode can have a HostWindow. The HostWindow is an ImGuiWindow that actually displays the dock content and tab bar . In a dockspace, the host window is the one you created (like “MainDockspace” window). For floating dock nodes, ImGui creates a temporary host window (with a generated title like “##DockNodeXXX”) which appears as the floating platform window containing the tabs. The HostWindow is what gets rendered and moved around.
	•	The concept of Central Node: If a dockspace is created, by default ImGui designates one node as central (usually the first one, or the one that is not split off by others). That central node is special in that it extends to cover the whole remaining region of a dockspace and stays even if empty . It prevents the situation where you could dock all windows out and have an entirely empty gap. (Currently, creating a dockspace always creates a central node by default ).

Persistent Layout and .ini Settings: ImGui’s docking system will automatically save the dock layout in the .ini settings (unless disabled). Each dock node’s arrangement and which windows were docked where are serialized. This means when you restart the application (or if you call LoadIniSettingsFromDisk), ImGui can restore the windows to their previous docked state. The .ini file will contain entries not just for individual windows (with their size/pos), but also a section for dock nodes. For example, you might see something like:

[Docking][Data]
DockSpace     ID=0x12345678 Window=MainDockSpace Size=1280x720 Split=Y
  DockNode    ID=0x10000001 Parent=0x12345678 SizeRef=640x720 CentralNode=Yes
    Window    Name="Scene"
    Window    Name="Game"
  DockNode    ID=0x10000002 Parent=0x12345678 SizeRef=640x720
    Window    Name="Properties"

(This is a conceptual illustration; actual format may differ). It encodes the tree of dock nodes and which windows are in each. So when ImGui initializes next time, if the same windows appear (matching by name or explicit GUID if set), it will recreate this dock layout. ImGuiDockNodeSettings internally is the structure used to store each node’s info for serialization. ImGui preserves dock node settings even if a node is not currently alive (e.g., if no window is docked in a spot this session, the saved data is kept around in case windows return) .

Because of this system, you get persistent layouts out of the box . Users can arrange their workspace, and the layout comes back on restart. If you want to manage layouts yourself, you can disable ImGui’s saving and use the DockBuilder API to set up layouts.

DockBuilder API: ImGui provides some low-level API (in imgui_internal.h) to manipulate dock nodes programmatically. For example, ImGui::DockBuilderSplitNode(node_id, direction, fraction, &out_id1, &out_id2) lets you split an existing node in code, and ImGui::DockBuilderDockWindow("WindowName", target_node_id) can dock a specific window into a given node. This is primarily for setting up default layouts or presets. The DockBuilder API is considered experimental and mostly wraps what the user could do by dragging, but it’s useful for configuring a complex interface at startup. ImGui’s authors mention that some parts of docking (especially DockBuilder and certain flags) are still subject to change , hence they keep them in the internal API. But in practice these are usable if needed.

Limits and quirks: The docking system is quite powerful, but there are some things to be aware of. ImGui does not yet support dragging docked windows out into a separate ImGui context (all docking happens within one shared context). It’s recommended to use one context with docking rather than trying to have multiple contexts as a workaround  . Some flags allow restricting docking: for example, window classes (ImGuiWindowClass) can be used to prevent certain windows from docking with others, or to enforce that a certain tool window can only dock in a specific area. Also, if using multiple viewports, docking can span across monitors as well (you could dock a window and then drag the whole dockspace to another monitor as a separate OS window). ImGui has some known issues on Linux (X11) where multi-viewport and docking have glitches with certain window managers , but on Windows and others it’s stable.

Not merged to master yet: It’s worth noting that as of now (2025), the docking branch is separate from master in ImGui’s repo (though frequently updated alongside it) . The author has stated that docking (current version v2) has some technical debt and he plans a “Docking v3” rewrite before official merge  . However, the docking branch is widely used and considered safe – many major teams use it in production . The API for most docking features is mostly through flags and DockSpace() calls, so typical users aren’t heavily affected by internal changes . In short, you can rely on the docking branch for projects now (and indeed it’s recommended for advanced users), just be prepared for possible small API adjustments if/when the final version lands.

In practice, docking greatly improves ImGui’s capability to make complex editors. You can create a full multi-panel interface (left panel, right panel, bottom panel, central view, etc.) all dockable and rearrangeable by the user, similar to Unity or Unreal Engine editors. ImGui handles all the tricky math of splits and tab bars for you. It even supports hidden tab bars (you can hide the tab bar if a dock node has only one window to save space ), and windows can have close buttons on their tabs, etc. The Metrics/Debug window (ShowMetricsWindow()) in docking branch also visualizes the dock node tree, which is helpful for debugging layouts .

To summarize, the docking system introduces a hierarchical layout container (dock nodes) allowing windows to be combined. It seamlessly integrates with ImGui’s existing windowing: you still create windows with ImGui::Begin() as usual; docking decides whether that window is presented alone or inside a dock node with others. Most docking usage can be done with just config flags and perhaps a call to create a dockspace region . ImGui takes care of the rest – saving layouts, handling drag and drop of window tabs, resizing splits, etc. This elevates Dear ImGui from a simple overlay GUI to a framework capable of building entire application interfaces with multiple panels.

Multi-Viewport and Multiple Window Support

The docking branch of ImGui also includes the Multi-Viewport feature (sometimes called multi-window in ImGui context). This feature allows ImGui to create additional OS-level windows for ImGui content, not just child windows inside a single application window . In effect, ImGui windows can break out of the main application window boundary and become truly independent native windows with their own graphics context. This is essential for tools that want detachable panels or multi-monitor support in ImGui.

How to enable: Similar to docking, you enable multi-viewports via a config flag: io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;. You must be using a backend that supports it (most of the example backends in the docking branch do). Once enabled, ImGui will treat any window that is not docked into the main viewport as a candidate to spawn its own OS window. After rendering your main viewport, you need to call two extra functions in your render loop: ImGui::UpdatePlatformWindows(); ImGui::RenderPlatformWindowsDefault(); . These calls instruct ImGui to handle any new platform windows and render them. The OpenGL/DirectX backends typically also require you to restore your main context afterward (since RenderPlatformWindowsDefault might make one of those windows’ context current briefly) .

Main viewport vs secondary viewports: In multi-viewport mode, ImGui designates a Main Viewport (usually corresponds to your primary application window or the area you provided for ImGui). For example, if you have a game window and you overlay ImGui on it, that game window is the main viewport. ImGui will render all windows that are not torn out inside this main viewport by default. But if you drag an ImGui window outside the bounds of the main viewport (or if you explicitly create an ImGui window with the ImGuiWindowFlags_NoDocking|ImGuiWindowFlags_NoTitleBar|... and position it off-screen), ImGui will create a new Platform Window (a new OS window) for it. Each such window gets an ImGuiViewport structure (specifically an internal type ImGuiViewportP) which contains information like the OS window handle, size, position, DPI scale, etc.  .

ImGuiViewport and PlatformIO: ImGui::GetPlatformIO() provides access to the array of viewports. The main viewport is PlatformIO.MainViewport, others are in PlatformIO.Viewports array. Each viewport has flags (e.g. IsMinimized), a connection to a backing ImGuiWindow if it’s not an independent one, and pointers to the platform window created by the backend. The platform backend uses callbacks (in ImGuiPlatformIO) to create/move/resize/destroy these platform windows as needed . For example, when you drag a window out, ImGui will call the Platform_CreateWindow callback – the backend will create an OS window (say, an SDL Window or Win32 HWND), and store the handle in the viewport->PlatformHandle. ImGui then continues to render that viewport’s UI into its own draw data.

Coordinates and input: A crucial aspect is that when multi-viewports are enabled, ImGui switches to using absolute desktop coordinates for window positions . The origin (0,0) becomes the top-left of the primary monitor by default. If you have multiple monitors, ImGui knows each viewport’s monitor. The coordinate space change means that if earlier you used window positions in your code, they might now be in global space. However, ImGui provides helper functions like ImGui::GetMainViewport()->Pos to find the offset of your main viewport if needed. The reason for this change is so that as you drag windows out, their positions remain consistent in OS space – ImGui doesn’t have to do coordinate conversions when rendering them in their own OS windows.

Rendering multi-viewports: With viewports enabled, ImGui::GetDrawData() will contain only the draw data for the main viewport after ImGui::Render(). The separate viewports’ draw data are handled when you call RenderPlatformWindowsDefault(). What that does is essentially loop over each ImGuiViewport (except the main) and for each:
	•	It asks the renderer backend to set the render target for that window (e.g. make its GL context current or its swapchain active).
	•	It sets up the same projection and rendering pipeline for UI.
	•	It calls the render function with that viewport’s draw data (accessible via viewport->DrawData).
	•	After rendering, it might call the platform backend to swap buffers for that window.

So each viewport is drawn in turn. The result is multiple native windows each showing a portion of the ImGui interface. ImGui handles DPI per monitor as well: each ImGuiViewport has a DpiScale value; if a window moves to a monitor with different DPI, ImGui can adjust font scaling on that viewport (if enabled). The user may need to reload fonts at higher size for high DPI so text remains crisp.

Moving and resizing: ImGui relies on the backend to notify it of platform window moves and resizes. For example, when you click and drag the title bar of a viewport (OS window), the OS moves it – the backend (if it can) should call ImGui::GetPlatformIO().Platform_SetWindowPos to update ImGui’s notion of the viewport position. Some backends poll the OS window position each frame to update ImGuiViewport->Pos. When resizing an OS window, ImGui will likewise get the new size and update viewport->Size, which will reflect in ImGui’s layout next frame. There are PlatformIO callbacks for these (Platform_SetWindowPos, Platform_GetWindowSize, etc.). In practice, the example backends handle this, so using them means it just works.

Focus and input routing: When an ImGui viewport (OS window) is focused or hovered, the backend should send events to the corresponding ImGui context. The io.AddMouseViewportEvent() is used so ImGui knows which viewport the mouse is currently over . This is needed to handle dragging from one viewport into another, etc. Keyboard focus is global in ImGui (single context), but the concept of which viewport is focused matters for e.g. bringing that window to front. The docking branch also supports migrating windows between viewports. For example, if you drag a docked panel outside, it becomes a new viewport; if you drag it back in, ImGui will destroy the viewport (via Platform_DestroyWindow callback) and reintegrate it into the main window.

Multi-monitor & DPI: Multi-viewport allows ImGui windows on different monitors. ImGuiPlatformIO knows about monitors via an array of ImGuiPlatformMonitor structs (position, size, DPI scale). The backend is responsible for filling that (e.g. enumerating monitors and their DPI at init). With that, if you move a window to a different monitor, ImGui can scale the font if io.ConfigFlags_ViewportsNoAutoMerge or other DPI handling flags are set. There is an FAQ entry specifically on handling multi-monitor DPI in ImGui .

Use cases and limitations: Multi-viewport essentially lets ImGui break out of the confines of a single host window. This is useful for making an editor where you might want to drag a panel to another screen, or have an ImGui-based overlay tool that spawns a separate diagnostics window. It is an advanced feature – the ImGui code base marks it as such, and it expects a well-implemented backend to function. On some platforms like macOS, extra care is needed (macOS coordinate systems and DPI handling are a bit different). On Linux/Wayland, as noted, there are unresolved issues (Wayland doesn’t allow moving windows programmatically in some cases, etc.) .

Another subtle limitation: If your application already has multiple OS windows that each want an ImGui context, it is often better to use the multi-viewport system with one context instead of separate ImGui contexts. The ImGui documentation strongly prefers one context with viewports, because multiple contexts cannot share things easily (like font atlas, or dragging between windows, etc.) . With viewports, you can have one context and any number of windows.

From a performance perspective, each viewport is rendered separately, so if you have 5 ImGui OS windows, you’ll issue 5 sets of draw calls (one per window) each frame. This is typically fine (they’re just more draw calls), but it’s a consideration. If a viewport is minimized, ImGui can detect that and potentially skip rendering it (the backend sets a flag for minimized windows), saving GPU work.

Example: Imagine a scenario: You have a main application window with a menu bar and a dockspace (central node). Within it you have a “Scene” window and “Properties” window docked. Now you drag “Properties” out to a second monitor. ImGui will create a new viewport for Properties. The Properties ImGuiWindow now becomes ViewportOwned and isn’t rendered in the main viewport’s draw data. Instead it’s rendered in its own. The second monitor shows that window alone in a native OS window frame (the OS provides the border and close/minimize buttons – ImGui can disable rendering its own title bar so as not to duplicate). The backend ensures input for that window is fed when it’s focused. If you alt-tab away and back, ImGui knows which viewport is focused and can for example highlight the corresponding taskbar icon, etc., as needed. It’s very much like having multiple independent GUI windows, but all powered by one ImGui instance.

In conclusion, multi-viewport makes ImGui act like a multi-window UI toolkit while preserving the convenience of a single update loop. It requires robust backend support, and when enabled, it subtly changes ImGui’s coordinate handling to absolute coordinates . The feature greatly enhances ImGui’s usefulness for serious applications by allowing truly separate windows and multi-monitor support. Just keep in mind that on some platforms not all edge cases are solved (especially Linux), and that you’ll want to test DPI scaling if you use high DPI displays. ImGui’s own demo can demonstrate multi-viewport by enabling it in the demo window and showing that you can tear off the demo windows.

Performance and Optimization Techniques

Despite being a high-level UI library, Dear ImGui is designed for minimal CPU and memory overhead  . Here we summarize how ImGui achieves good performance and what techniques are available to optimize usage:
	•	Batched rendering: As discussed, ImGui batches draw calls extensively . This means switching UI themes or textures frequently can break batches (each unique texture will cause a new draw call), but typical UIs use one atlas for almost everything. As a result, rendering the UI often takes only a handful of GPU draw calls (often on the order of 5-50 draw calls even for very complex UIs). This reduces driver overhead and is friendly to tiler GPUs on mobile as well.
	•	Avoiding per-widget allocation: ImGui allocates memory mostly in large chunks. Windows, for example, are allocated from a container (and reused), and most widgets don’t allocate at all – they use the stack or ImGuiContext memory. ImGui’s ImVector (a std::vector-like) is used for things like vertex buffers, window lists, etc., and it typically doubles capacity when needed to avoid frequent reallocation. Therefore, if your UI has a stable complexity, ImGui will allocate memory for the worst-case usage and then reuse it each frame without new allocations. There are no complex object graphs being new’ed and deleted every frame, in contrast to some retained GUIs.
	•	Clipping and culling: Each ImGui window uses clipping rectangles to avoid drawing outside its boundaries. When ImGui adds vertices, it always associates them with a clip rect in the draw command. The rendering backend then scissor-tests out anything outside. However, ImGui still generates vertices for widgets even if they are off-screen within a scrollable area, unless you use an explicit culling mechanism. For list-like widgets, ImGui provides ImGuiListClipper – a utility to avoid submitting too many items. If you have a list of 10,000 items in a scrolling region, you can use ImGuiListClipper to calculate the range of visible items and only render those. This saves the CPU cost of formatting and issuing ImGui calls for items that won’t be seen. The ListClipper is highly recommended for large lists, as it can dramatically cut down CPU usage by not iterating over thousands of off-screen elements.
	•	Frame-to-frame coherence: ImGui doesn’t automatically retain state, but some elements are optimized to not recompute more than necessary. For example, the contents of a combo box (dropdown) or a menu are only computed when opened. If a window is collapsed or not visible (out of view or in an inactive viewport), ImGui will skip rendering it (it still processes basic window keep-alive so it knows it exists, but doesn’t generate draw commands). This means having many windows hidden or collapsed is virtually free beyond a small bookkeeping cost. ImGui windows that are off-screen in a viewport (say you moved a window far outside) will have their draw commands clipped by the scissor (though ImGui will still produce them unless you explicitly cull via code). A lot of ImGui’s performance relies on the assumption that typical UI frames are not massively complex (in terms of number of visible widgets). If you push it (like 10000 visible widgets), the cost will scale roughly linearly.
	•	Efficient text rendering: ImGui uses a bitmap font atlas. All text rendering boils down to copying vertices for textured quads. There is no dynamic text shaping or complex layout going on (no word-wrapping unless you explicitly use TextWrapped or InputTextMultiline with specific flags). By default, ImGui glyphs are 1:1 from the font texture, which is efficient. If you need to display extremely large amounts of text (logs, etc.), consider using ImGuiTextBuffer or chunking the text to avoid huge single ImDrawList::AddText calls. But generally, text is quite optimized. There’s an optional feature to do faster line anti-aliasing by using a small texture of a circle to draw round edges (this trades computation for a bit of texture memory).
	•	No background thread, but not needed: ImGui runs entirely on the thread that calls it (usually the main thread). For GUI, this is acceptable since it’s not very heavy. ImGui doesn’t use threads internally (except if you explicitly call e.g. TextColored from multiple threads with different contexts, which is not typical). The single-threaded nature avoids synchronization overhead. The immediate mode approach also means you don’t have to marshal data or events between threads.
	•	Profiling and metrics: ImGui includes a Metrics window (ShowMetricsWindow()) which can help identify performance issues by showing the number of vertices, windows, etc., each frame. If you see e.g. 5 million vertices, you know something (perhaps an overly large ImPlot or a huge list not clipped) is the culprit. Reducing the amount of work by clipping or simplifying drawing (e.g. turning off unnecessary heavy ImDrawList usage) will help.
	•	Memory footprint: A basic ImGui context might be on the order of a few hundred KB to a couple MB (depending on font texture size). Each window has some overhead (a structure ~few KB plus any child draw lists). But it’s overall quite small relative to typical application memory. The biggest memory usage is often the font atlas if you load big fonts or many ranges (the default 8x8k atlas for 8 pt font and icons might be ~1-2MB).
	•	Optimizing specific widgets: If you have custom widgets that are heavy, consider their complexity. For example, ImPlot (next section) can plot thousands of points – to keep interactive performance, it might skip plotting every single pixel if not needed. If you write a custom graph, you might do similar (e.g. skip sub-pixel oscillations that don’t show up). ImGui’s draw list can handle tens of thousands of primitives fine, but hundreds of thousands per frame might start to be noticeable CPU-wise. Always measure – but generally ImGui is “immediate” but not “inefficient.”

In practice, developers find Dear ImGui sufficiently fast for most use cases out-of-the-box . If your UI is simple (few hundred widgets), it will consume a negligible amount of CPU (often less than 0.1 ms per frame in many cases). If your UI is complex (thousands of items), using the provided helpers (like clipping large lists) and avoiding needless work (don’t rebuild UI that isn’t on screen) will keep it within a few milliseconds. The biggest optimization is often simply not doing unnecessary work in your own code (e.g. heavy calculations each frame that aren’t needed). ImGui’s design (no heavy per-widget update unless it’s visible and being interacted with) means it scales well as you increase dynamic content.

Finally, one often-cited advantage: because ImGui does not have a lot of hidden state and synchronization, it’s easy to tune performance by adjusting your usage patterns. For example, if you had an extremely large table, you could render only a subset or update it less frequently. ImGui won’t complicate that with internal timers or lifecycles – you are in control of what gets submitted each frame. This determinism helps in maintaining smooth performance.

ImPlot: Plotting Extension for ImGui

ImPlot is an extension library that provides immediate-mode plotting widgets, designed to integrate with Dear ImGui. It allows creation of plots, charts, and graphs in a way that feels like a natural extension of ImGui’s API. ImPlot is built by the community (originally by Evan Pezent) and is often used alongside ImGui for scientific data visualization or editor tools that need plots.

Integration and architecture: ImPlot is a backend-agnostic, header-only (or compiled) library that depends on ImGui. To use ImPlot, you include its source (implot.h/.cpp) and create an ImPlot context with ImPlot::CreateContext() after you have an ImGui context . This context holds ImPlot’s internal state (like currently active plot, plot items, colormaps, etc.). ImPlot uses ImGui’s current context for rendering; if ImGui is split into a DLL or separate context, you can link them by calling ImPlot::SetImGuiContext(ImGuiContext* ctx) to ensure ImPlot calls operate on the correct ImGui state . In typical usage (statically linking ImPlot with ImGui in the same program), you don’t need to worry about that – just create the contexts and they’ll hook together.

ImPlot draws everything using ImGui’s drawing lists. When you create a plot (ImPlot::BeginPlot("My Plot")), under the hood ImPlot will start a new ImGui child region or use the current window to draw the axes and data. ImPlot outputs draw commands (lines, markers, text) to ImGui’s draw lists, so from the perspective of the rendering backend, there’s no difference between ImPlot’s output and the rest of ImGui’s draw data – it’s just more triangles and lines. This means ImPlot’s plots appear in ImGui windows, and you can position or dock those windows like any other. Style-wise, ImPlot tries to use ImGui’s style where appropriate (e.g. text color, maybe the ImGui color style for things like frame backgrounds for the plot area), but it also defines its own color palette for plot lines and fills. For example, ImPlot sets default line colors (blue, orange, green, etc.) for different plot items. These are configurable via ImPlot::GetStyle() which returns an ImPlotStyle structure or via push style functions.

ImPlot is immediate mode just like ImGui . You typically feed it your data arrays every frame. For example, to plot a line you might have an array of x values and y values and call ImPlot::PlotLine("Label", x_data, y_data, count). ImPlot doesn’t store those arrays internally (except maybe a pointer for the duration of that plot render); it will transform them to draw list primitives each frame. This means if your data changes, you just call PlotLine with new values and the graph updates. If data is static, you’re still calling PlotLine each frame (which might recompute points), but this overhead is usually small. ImPlot’s philosophy is similar to ImGui: ease of use and real-time plotting, even if that means re-sending data each frame, since in practice that’s often fine (and if not, you can optimize by only calling plot when needed, etc.).

Plotting features: ImPlot supports a wide range of plot types and features out of the box  :
	•	Multiple plot items: lines, scatter points, bars (vertical and horizontal), error bars, shaded region plots, stem plots, stair steps, pie charts, heatmaps, histograms (1D and 2D), images in plots, etc. You can mix and match items on the same plot (e.g., a line series with some scatter points on top) .
	•	Configurable axes: Each plot can have up to three x-axes and three y-axes . This means, for instance, you can have one plot with a primary y-axis on the left, and a secondary y-axis on the right for another scale (and even a tertiary if needed). Same for x (top and bottom). By default you usually use X1 and Y1. Additional axes can be enabled with ImPlotAxisFlags when beginning the plot. Axes can be linear or logarithmic scale, and ImPlot supports time (date/time) formatting on axes . You can also invert axes, apply limits, or lock them.
	•	Axis labels and units: You can set labels for axes (including UTF-8 text) when you create the plot or via setup functions. The tick marks on axes are either automatically generated or can be manually specified. ImPlot will pretty-print numbers or times on axes; you can also supply custom formatters.
	•	Interactivity: ImPlot plots by default allow the user to zoom, pan, and query data:
	•	Zooming – The scroll wheel zooms in/out centered at the mouse position. By default, the y-axis might also zoom with ctrl+scroll or such (configurable). The axes can be linked or independent. ImPlot maintains the axis ranges in the ImPlotContext.
	•	Panning – Click-and-drag (usually left mouse drag) on the plot area will pan the axes. Dragging on an axis (like grabbing the axis ticks area) will pan only that axis.
	•	Box selection – You can drag with right-mouse (or a modifier + left) to draw a selection rectangle. On release, ImPlot will zoom into that selected region (adjusting the axis ranges to the selection). This provides a quick way to zoom into an area of interest.
	•	Querying – ImPlot has a concept of a query region: you can drag perhaps with middle mouse (or a specific tool) to select a region without zooming, and that region can remain highlighted (persistent) . The app can then use ImPlot::GetPlotQuery() to retrieve the range of that box for analysis (for example, find min/max of data in that range). This is the “persistent query ranges” feature .
	•	Hover tooltips – By default ImPlot shows the data values under the cursor in a small tooltip. If you hover near a line, it might show the interpolated y-value at the x-position, etc. It can also highlight the nearest point. ImPlot’s demo shows this with markers highlighting the closest point on hover.
	•	Legend – Plots can have an optional legend (showing labels of each series, with colored icons). You can click legend entries to hide/show series (toggling their visibility).
	•	Annotations/Tags – ImPlot allows adding text annotations at specific plot coordinates via ImPlot::Annotation() (for marking special points) and vertical/horizontal markers via ImPlot::TagXX() etc. The internal code snippet confirms an ImPlotAnnotation struct exists . These annotations are drawn in the plot and move/zoom accordingly.
	•	Drag and drop – ImPlot items support ImGui’s drag-and-drop to some extent: you can drag data from one plot to another or use color dragging to restyle series.
	•	Styling: ImPlot’s styling is separate but mirrors ImGui in spirit. There is an ImPlotStyle structure (fields for line weight, marker shapes, alpha, etc.) and an ImPlotColormap for series colors. ImPlot provides several built-in colormaps (e.g. default, deep, dark, pastels, etc.), and you can push a colormap to style a particular plot. You can also individually style plot items (change a single line’s color or marker). ImPlot’s style is accessible via ImPlot::GetStyle() to tweak at runtime. It attempts to use ImGui’s current style for things like text size (so it uses the same font and size as ImGui) and perhaps colors for things like plot border or background to be coherent with ImGui theme. There’s an option to automatically match the ImGui style (likely adjusting the grid color brightness if ImGui is dark theme, etc.). The ImPlot demo has an example of toggling through colormaps.
	•	Performance considerations: Plotting can be heavy if you have huge data, but ImPlot is written in C++ with performance in mind. It uses internally things like ImVector for points and tries to avoid heap allocs during plot rendering (most allocations happen when you add a new item, not each frame). For large line plots, ImPlot will typically just iterate your arrays and transform points to ImGui coordinates. This is usually fast (a million points might be borderline to do each frame on the CPU, but a few hundred thousand is fine). The rendering backend needs to support large meshes: as noted, if you plot >65k points in a single line strip, you must enable 32-bit indices or the VtxOffset feature  (to split the draw into multiple calls). Many default backends do support this (e.g. DX11, OpenGL3 backends set ImGuiBackendFlags_RendererHasVtxOffset, meaning they can handle offset indices). If not, ImPlot’s documentation highly recommends enabling 32-bit indices in ImGui  to avoid index overflow.

For extremely large data sets, some users implement decimation (down-sampling) before feeding to ImPlot (since subpixel lines can be skipped). ImPlot itself doesn’t automatically downsample your data; it leaves that choice to you for now. But it is “GPU accelerated” in the sense that all the actual drawing is done by the GPU once ImPlot hands off the vertices. If your data is dynamic, pushing updates is straightforward: just call the same PlotX functions with new data arrays and the plot moves. Memory-wise, ImPlot doesn’t make internal copies of your data unless you use helpers that do (there are some functions that accept callbacks or that can stride through user data). It mostly references your pointers during the plot call.
	•	Advanced axes features: Secondary axes (up to 3) allow things like showing two different units. For example, you might have temperature in C on one y-axis and F on the other, updating simultaneously. ImPlot supports linking axes to external variables – via ImPlot::LinkAxis(ImAxis_Y1, &ymin, &ymax) you can tie an axis range to your own double variables, for instance. There are also constraints (you can set ImPlotAxisFlags_LockMin or min/max limits so users cannot zoom/pan beyond certain range). The ImPlotAxis internal struct shows fields for constraints and links  . It also shows an ImPlotTransform with forward/inverse functions for custom transformations (so you could plot data in a non-linear custom scale by providing transform callbacks).
	•	Multiple plots and subplots: You can create multiple independent plots in different ImGui locations. ImPlot also has a concept of subplots (a grid of plots with shared axes) in newer versions – e.g. ImPlot::BeginSubplots() which allows you to create an arrangement of plots that can share an x-axis or be linked.

Using ImPlot in code might look like:

ImGui::Begin("My Window");
if (ImPlot::BeginPlot("Stock Prices")) {
    ImPlot::SetupAxes("Time","Price", ImPlotAxisFlags_Time, ImPlotAxisFlags_AutoFit);
    ImPlot::PlotLine("Stock A", times, pricesA, count);
    ImPlot::PlotLine("Stock B", times, pricesB, count);
    ImPlot::EndPlot();
}
ImGui::End();

This would create a plot with two lines and nicely labeled time x-axis and an auto-fitting y-axis. All of that would render inside “My Window”.

ImPlot and ImGui styling synergy: ImPlot intentionally mirrors a lot of ImGui conventions. For example, it uses state-pushing functions like ImPlot::PushStyleColor() to override colors and PopStyleColor(), similar to ImGui. It uses the same font (by default it calls ImGui::GetFont() and ImGui::GetFontSize()). One thing to note: because ImPlot can draw a lot of primitives, if you have really heavy anti-aliased lines, you might want to ensure your ImGui style’s AntiAliasedLines is enabled (which it is by default) and possibly use texture-based AA for very thick lines (ImGui has a style option AntiAliasedLinesUseTex which is recommended for better quality at 1px lines ). The ImPlot FAQ even points that out if you see aliasing on plots .

Examples of features: ImPlot can do things like:
	•	Plot two y-axes: e.g. left axis for one data series, right axis for another. This is done by enabling a second y-axis and then specifying ImPlot::SetPlotYAxis(1) before plotting the second series, to tell ImPlot to use Y-axis 2 for that series.
	•	Annotations: Marking a specific (x,y) with text, e.g. marking peaks.
	•	Drag points/lines: ImPlot provides ImPlot::DragPoint() and ImPlot::DragLineX/Y() which create an interactive point or line that the user can drag, updating a value. For example, a horizontal threshold line that the user can move up/down, or a specific data point control. These use ImGui’s active id and behaviors internally to allow dragging the element and they update the provided value in real-time.
	•	Real-time updating: ImPlot is designed to handle changing data each frame (e.g. streaming new samples). Many users use it for scopes or performance graphs that update every frame or at high frequency. It’s efficient enough for that as long as the number of points per frame isn’t huge (or if it is, one might use a rolling buffer and pop old points).
	•	Context menus: ImPlot itself doesn’t add a context menu, but you can easily create one by detecting right-click (ImGui::IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup) && ImGui::IsMouseReleased(ImGuiMouseButton_Right)) and using ImGui::OpenPopup. Some user extensions add context menus for e.g. copying data or switching scales.

Integration summary: From the integration standpoint, ImPlot is just another set of ImGui calls. There’s no separate render loop or thread. You call ImPlot functions between ImGui::Begin/End as needed. The only extra maintenance is creating/destroying the ImPlot context (which is small) at app start/exit. If ImGui is compiled as a DLL, you ensure ImPlot knows about ImGui’s context via SetImGuiContext. If both are static or compiled together, it just works. ImPlot relies on ImGui for input: it checks ImGui’s IO for mouse position relative to plot, mouse clicks, etc. For instance, the zooming and panning use ImGuiIO mouse wheel and drag information. It does not create its own input system.

ImPlot complements ImGui by providing higher-level visualization components that would be tedious to implement from scratch each time. It adheres to the immediate mode paradigm (you describe what to plot every frame) , which makes it feel consistent with ImGui (no need to manage persistent plot objects unless you want to). The design of ImPlot demonstrates how one can build complex functionality on top of ImGui’s infrastructure: it uses ImGui windows, draws via ImDrawList, and manages state with its own context that ties into ImGui’s context.

Other Notable ImGui Extensions

Beyond ImPlot, a variety of community extensions build on Dear ImGui to provide additional widgets and tools. Here are a few popular ones (that can be explored separately) which might be relevant:
	•	ImGuizmo: An immediate mode 3D gizmo for scene editing . It lets you manipulate 3D transforms (position/rotation/scale) via draggable axes and rotation rings drawn on top of a 3D view. It integrates with ImGui by drawing over a viewport (as seen in the example image above, the colored axis widget labeled “Orthographic” hint). ImGuizmo is useful in game editors to move objects with the mouse in 3D space.
	•	imgui-node-editor (Nodes GUI): A node graph editor for ImGui . It provides a canvas where you can create nodes with input/output slots and connect them with links (useful for visual scripting, material editors, etc.). This extension handles panning/zooming a node canvas and the interactive linking of pins, all within an ImGui context.
	•	ImGuiColorTextEdit: A colorizing text editor widget. It extends ImGui with a text editor that supports syntax highlighting, line numbers, undo/redo, etc., often used for embedding code editors or log viewers in ImGui interfaces.
	•	ImGuiFileDialog: A file browser dialog for ImGui, allowing users to select files or directories in a familiar dialog style (since ImGui doesn’t have a native file dialog).
	•	Dear ImGui Bundle: A collection of useful add-ons bundled together (including ImPlot, ImGuizmo, node editor, and others) for convenience .
	•	ImTerm or ImGuiConsole: Simple terminal/console emulator widgets that allow interactive command-line input and output within an ImGui window (often used for debugging consoles in applications).
	•	ImGui Debuggers/Tools: There are extensions to integrate with remote interfaces or profilers (e.g. Remotery’s ImGui integration for profiling), or game-specific tools like imgui interfaces for engine debugging.

Each of these extensions follows the spirit of ImGui’s design: they operate in the immediate mode style (often just additional ImGui calls) and typically require including their source and calling their update/draw functions inside an ImGui frame. They are not part of core ImGui but illustrate its extensibility. As our focus is on core ImGui and ImPlot, we won’t dive deeply into these, but it’s good to know they exist for future use. With ImGui’s docking and multi-viewport capabilities, many of these can be used together to create a comprehensive, complex application UI entirely within the ImGui ecosystem.

Sources:
	•	Official Dear ImGui documentation, wiki, and changelogs    
	•	ImGui GitHub issues and dev comments on custom widgets and usage 
	•	ImGui Multi-Viewport and Docking wiki pages  
	•	ImPlot README and FAQ for integration and features   
	•	Alex Dixon’s blog on ImGui backend (for general ImGui architecture insights) 